<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JOJOTOV</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/official_account_avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://dingtz.com/atom.xml" title="JOJOTOV"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/blogLogo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jojoting" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://cn.linkedin.com/in/同舟-丁-77689b10b" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/18/Link（直达链接）开发/" class="post-title-link">iOS9 UniversalLink（直达链接）开发</a></h2><div class="post-info">Dec 18, 2016</div><div class="post-content"><p>###背景<br>在iOS 9以前，我们从外部启动App都是通过URL Scheme实现跳转的。这种方式虽然可自定程度很高，能够巧妙地实现很多跳转，但弊端也很明显：我们只能通过scheme://example这种格式的链接来实现跳转，而且现在苹果还对这种方式的跳转加了一个提示框：“是否打开XXX”。对于对Web和原生App交互的场景需求量很大的产品来说，这样的跳转方式显然是步骤冗杂的，用户体验并不好。</p>
<p>iOS 9以后，Universal Link的出现解决了这个问题。它所提供的直接、顺畅、无缝衔接的跳转能够让用户体验提升一个级别。用户可以点击开发者指定的类似于<code>https://example.com/t</code>的URL直接唤醒App，而不需要在浏览器打开再点击其他按钮。</p>
<p>在你的App中添加这个功能很简单：</p>
<blockquote>
<ul>
<li><p>在<a href="https://developer.apple.com/account/">苹果开发者网站</a>中打开需要使用Universal Link功能的App中的Associated Domains</p>
</li>
<li><p>上传apple-app-site-association到服务器根目录下</p>
</li>
<li><p>在AppDelegate中实现相应的方法</p>
</li>
</ul>
</blockquote>
<p>###配置<br>首先，我们要在<a href="https://developer.apple.com/account/">苹果开发者网站</a>中开启App的Associated Domains功能。</p>
<p>在<em>Account -&gt; Certificates, Identifiers &amp; Profiles -&gt; App IDs -&gt; YourApp -&gt; Edit</em>中把Associated Domains设置为Enable</p>
<p>然后我们需要配置一下工程文件，找到<em>Capabilities -&gt; Associated Domains</em></p>
<p>打开此功能并把你需要跳转的domain加进去，格式为<code>applinks://www.example.com</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/797083-d529f0746b0b6cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>###部署</p>
<blockquote>
<p>####注意</p>
<p>首先你的服务器必须得支持SSL</p>
</blockquote>
<p>接下来，我们需要上传一个json文件到我们的服务器。json文件以apple-app-site-association命名</p>
<blockquote>
<p>####注意</p>
<p>文件不需要添加任何后缀</p>
</blockquote>
<p>json的格式是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;applinks&quot;: &#123;</div><div class="line">    &quot;apps&quot;: [],</div><div class="line">    &quot;details&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;appID&quot;: &quot;TeamID.com.domain.App&quot;,</div><div class="line">        &quot;paths&quot;:[ &quot;*&quot; ]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>appID</code>：TeamID加上Bundle ID</p>
</li>
<li><p><code>paths</code>：支持Universal Link，也就是可以跳转的路径。<code>*</code>代表此域名下所有路径都支持，也可以具体制定到某个页面例如<code>/path/page</code>或者某个路径下所有URL例如<code>/path/*</code></p>
</li>
</ul>
<p>关于<code>paths</code>的配置，可以参考苹果官方文档</p>
<blockquote>
<ul>
<li><p>Use * to specify your entire website</p>
</li>
<li><p>Include a specific URL, such as /wwdc/news/, to specify a particular link</p>
</li>
<li><p>Append <em> to a specific URL, such as /videos/wwdc/2015/</em>, to specify a section of your website</p>
</li>
<li><p>In addition to using <em> to match any substring, you can also use ? to match any single character. You can combine both wildcards in a single path, such as /foo/</em>/bar/201?/mypage.</p>
</li>
</ul>
</blockquote>
<p>最后，我们只需要把配置好的json文件上传到服务器中该域名的根目录下，言下之意，我们可以用GET请求可以获取到<code>https://www.example.com/apple-app-association</code> </p>
<blockquote>
<p><strong>再次强调必须是HTTPS协议</strong></p>
</blockquote>
<p>当我们的App在设备上第一次运行时，如果支持Associated Domains功能，那么iOS会自动去GET定义的Domain下的<code>apple-app-site-association</code>文件。</p>
<p>需要留意iOS会先请求<code>https://domain.com/.well-known/apple-app-site-association</code>如果此文件请求不到，再去请求<code>https://domain.com/apple-app-site-association</code></p>
<p>所以如果想要避免服务器接收过多GET请求，可以直接把<code>apple-app-site-association</code>放在<code>./well-known/</code>目录下</p>
<blockquote>
<p>####注意</p>
<p>服务器上<code>apple-app-site-association</code>的更新不会让iOS本地的<code>apple-app-site-association</code>同步更新，即iOS只会在App第一次启动时请求一次，以后除非App更新或重新安装否则不会在每次打开时请求<code>apple-app-site-association</code></p>
</blockquote>
<p>###开发<br>待我们服务器部署好了，用curl测试一下<code>apple-app-site-association</code>能够正确GET到了,那么我们就需要在工程中响应跳转事件了。</p>
<p>我们在AppDelegate中实现如下代理方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> * _Nullable))restorationHandler&#123;</div></pre></td></tr></table></figure>
<p>具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> * _Nullable))restorationHandler&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (![userActivity.activityType isEqualToString:<span class="built_in">NSUserActivityTypeBrowsingWeb</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//读取url地址</span></div><div class="line">    <span class="built_in">NSURL</span> *webUrl = userActivity.webpageURL;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (![webUrl.path isEqualToString:<span class="string">@"/show"</span>]) &#123;</div><div class="line">        <span class="comment">//path错误，直接从safari打开</span></div><div class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] openURL:webUrl];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//跳转并显示内容</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"notify"</span> object:<span class="string">@"hello world"</span>];</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的自由度就很高了，我们可以根据传入的任何符合跳转条件的URL进行不同的操作。</p>
<p>###测试<br>现在一切都已经完成了，现在我们可以在短信中点击一个URL直接跳转到我们的App。至于如何检验URL是否能够跳转，一个快捷方便的方法就是在系统原生App中（如短信、邮件等）长按URL，如果弹出的选项中有<strong><em>在“your app”中打开</em></strong>，那么证明该URL是支持跳转的。</p>
<blockquote>
<p>####注意</p>
<p>非系统原生App不一定能支持直接点击URL跳转，例如在微信中点击URL会首先在微信内的WebView打开，如果要跳转只能再通过Safari打开。</p>
</blockquote></div><a href="/2016/12/18/Link（直达链接）开发/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/18/使用presentingViewcontroller属性可能会遇到的坑/" class="post-title-link">使用presentingViewController属性可能会遇到的坑</a></h2><div class="post-info">Dec 18, 2016</div><div class="post-content"><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假设现在有这样一个场景，我有一个根导航控制器<code>RootNavigationController</code>，它的根视图控制器<code>ViewController</code>有一个子控制器<code>UINavigationController</code>，这个导航控制器的根控制器是<code>FirstViewController</code>。</p>
<p>在<code>FirstViewController</code>中，添加一个方法使用<code>presentModelViewController</code>的方式跳转到另一个根控制器为<code>NextViewController</code>的<code>UINavigationController</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/797083-a034d3bd0033a0a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制器层级"></p>
<p>如果<code>NextViewController</code>中获取它的<code>presentingViewController</code>属性，结果得到的是<code>RootNavigationController</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-12-18 10:34:09.548 PresentVCDemo[27202:22455163] viewDidLoad &lt;RootNavigationController: 0x7ff29f83ba00&gt;</div><div class="line">2016-12-18 10:34:09.549 PresentVCDemo[27202:22455163] viewDidLoad &lt;ViewController: 0x7ff29de05870&gt;</div><div class="line">2016-12-18 10:34:09.572 PresentVCDemo[27202:22455163] viewDidLoad &lt;UINavigationController: 0x7ff29f022a00&gt;</div><div class="line">2016-12-18 10:34:09.573 PresentVCDemo[27202:22455163] viewDidLoad &lt;FirstViewController: 0x7ff29dc0c680&gt;</div><div class="line">2016-12-18 10:34:52.785 PresentVCDemo[27202:22455163] Presenting Controller : &lt;RootNavigationController: 0x7ff29f83ba00&gt;</div></pre></td></tr></table></figure>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>苹果官方的<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW7">ViewController Programming Guide</a>中关于<strong>Presenting a View Controller</strong>的部分是这样说的</p>
<blockquote>
<p>The view controller that calls the presentViewController:animated:completion: method may not be the one that actually performs the modal presentation. The presentation style determines how that view controller is to be presented, including the characteristics required of the presenting view controller. </p>
</blockquote>
<p>也就是说，在调用<code>presentViewController:animated:completion:</code>方法时，真正作为跳转的容器并不一定是调用这个方法的view controller，而是取决于<code>modalPresentationStyle</code>。例如，一个全屏的跳转必须由一个全屏的view controller来完成。如果当前的控制器不能满足，那么系统会自动沿着视图控制器的层级向上查找。</p>
<p>在我们的层级中，只有两个<code>UINavigationController</code>是全屏的，因此，这两个控制器都有可能成为最终跳转的容器。可是为什么最终是<code>RootNavigationController</code>完成了这次跳转而不是<code>FirstViewController</code>的导航控制器呢？</p>
<p>在<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/TheViewControllerHierarchy.html#//apple_ref/doc/uid/TP40007457-CH33-SW1">The View Controller Hierachy</a>关于Presented View Controller中找到了这样一句话：</p>
<blockquote>
<p>When you present a view controller, UIKit looks for a view controller that provides a suitable context for the presentation. In many cases, UIKit chooses the nearest container view controller but it might also choose the window’s root view controller.</p>
</blockquote>
<p>因此，在一开始提到的场景中，UIKit帮我们选择了UIWindow的根视图控制器，而不是<code>FirstViewController</code>的导航控制器。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在某些特定的业务需求中，我们需要利用<code>presentingViewController</code>拿到<code>FirstViewController</code>的导航控制器。</p>
<p>解决这个需求，我们需要用到一对属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> definesPresentationContext;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalPresentationStyle</span> modalPresentationStyle;</div></pre></td></tr></table></figure></p>
<p><code>modalPresentationStyle</code>属性决定了将要present的控制器以何种方式展现，默认值为<code>UIModalTransitionStyleCoverVertical</code></p>
<p><code>definesPresentationContext</code>就有点神奇了，他的注释文档是这么写的</p>
<blockquote>
<p>Determines which parent view controller’s view should be presented over for presentations of type UIModalPresentationCurrentContext.  If no ancestor view controller has this flag set, then the presenter will be the root view controller.</p>
</blockquote>
<p>简单来说，如果把一个控制器的<code>definesPresentationContext</code>属性设置为YES，那么在需要进行<code>UIModalPresentationCurrentContext</code>类型的跳转的时候，UIKit会使用视图层级内的这个控制器来进行跳转。</p>
<p>在<code>FirstViewController</code>中加入下面的代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.navigationController setDefinesPresentationContext:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></p>
<p>并在跳转的时候设置目标控制器的<code>modalPresentationStyle</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[nav setModalPresentationStyle:<span class="built_in">UIModalPresentationCurrentContext</span>];</div><div class="line">[<span class="keyword">self</span> presentViewController:nav animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>接下来看一下Log日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-12-18 11:59:20.041 PresentVCDemo[32336:22885768] viewDidLoad &lt;RootNavigationController: 0x7fd6f4810600&gt;</div><div class="line">2016-12-18 11:59:20.042 PresentVCDemo[32336:22885768] viewDidLoad &lt;ViewController: 0x7fd6f2c04110&gt;</div><div class="line">2016-12-18 11:59:20.052 PresentVCDemo[32336:22885768] viewDidLoad &lt;UINavigationController: 0x7fd6f381ce00&gt;</div><div class="line">2016-12-18 11:59:20.052 PresentVCDemo[32336:22885768] viewDidLoad &lt;FirstViewController: 0x7fd6f2f090c0&gt;</div><div class="line">2016-12-18 11:59:20.920 PresentVCDemo[32336:22885768] Presenting Controller : &lt;UINavigationController: 0x7fd6f381ce00&gt;</div></pre></td></tr></table></figure></p>
<p>大功告成！现在<code>presentingViewController</code>能够获取到我们期望的对象了。</p></div><a href="/2016/12/18/使用presentingViewcontroller属性可能会遇到的坑/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/09/NSProxy——少见却神奇的类/" class="post-title-link">NSProxy——少见却神奇的类</a></h2><div class="post-info">Aug 9, 2016</div><div class="post-content"><p>众所周知，NSObject类是Objective-C中大部分类的基类。但不是很多人知道除了NSObject之外的另一个基类——NSProxy<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_ROOT_CLASS</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这个奇怪的类是干嘛的？请允许我做一个黑人问号脸<br>马上查了一下Apple的官方文档：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/">NSProxy</a></p>
<blockquote>
<p>NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that don’t exist yet. Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDistantObject_Class/index.html#//apple_ref/occ/cl/NSDistantObject">NSDistantObject</a>) or for lazy instantiation of objects that are expensive to create.</p>
</blockquote>
<p>总的来说，NSProxy是一个虚类，你可以通过继承它，并重写这两个方法以实现消息转发到另一个实例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel;</div></pre></td></tr></table></figure></p>
<p>现在NSProxy的真面目终于浮出水面：<strong>负责将消息转发到真正的target的代理类</strong>。举个例子，你想要卖一件二手物品，但是你并不想直接跟卖家接触<strong>（直接向target发消息）</strong>，这时你去找了一个第三方，你告诉这个第三方你要买什么、出多少钱买、什么时候要等<strong>（向代理发消息）</strong>，第三方再去跟卖家接触并把这些信息转告卖家<strong>（转发消息给真实的target）</strong>，最后通过第三方去完成这个交易。</p>
<p>了解完NSProxy是是什么以后，那么它究竟能帮我们干些什么呢？</p>
<p>##通过NSProxy在Objective-C中模拟多继承</p>
<p>多继承在编程中可以说是比较有用的特性。举个例子，原本有两个相互独立的类A和类B，它们各自继承各自的父类，项目进行地好好的，突然有一天产品经理过来告诉你，我要在下个版本加一个xxxxx的特性，非常紧急。一脸懵逼的你发现如果要实现这个特性，你需要对类A以及其父类作很大的修改，代价非常之高。突然你意识到原来类B的父类已经有类似的功能，你只需要让类A继承于类B的父类并重写其某些方法就能实现，这样做高效且低风险，于是你屁颠屁颠地撸起了代码。</p>
<p>可是，Objective-C却不支持这样一个强大的特性。不过NSProxy可以帮我们在某种程度上（这只是一个模拟的多继承，并不是完全的多继承）解决这个问题：</p>
<p><code>现在假设我们想要去买书，但是我懒癌犯了，不想直接去书店（供应商）买，如果有一个跑腿的人（经销商）帮我去书店买完，我再跟他买。同时，我买完书又想买件衣服，我又可以很轻松地在他那里买到一件衣服（多继承）。</code></p>
<p>首先，我们定义BookProvider类与ClothesProvider类作为基类。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  TDBookProvider.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TDBookProviderProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)purchaseBookWithTitle:(<span class="built_in">NSString</span> *)bookTitle;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TDBookProvider</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  TDClothesProvider.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span> (<span class="built_in">NSInteger</span>, TDClothesSize)&#123;</div><div class="line">    TDClothesSizeSmall = <span class="number">0</span>,</div><div class="line">    TDClothesSizeMedium,</div><div class="line">    TDClothesSizeLarge</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TDClothesProviderProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)purchaseClothesWithSize:(TDClothesSize )size;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TDClothesProvider</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里要注意：<strong>一定要通过protocol来声明接口，而不是直接在类的@interfere中定义。</strong>因为通过protocol来声明接口，然后让proxy类遵循此协议，可以骗过编译器防止编译器提示proxy类未声明接口的错误。这个问题下面可以看到。</p>
<p>然后是这两个类的实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  TDBookProvider.m</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"TDBookProvider.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TDBookProvider</span> () &lt;<span class="title">TDBookProviderProtocol</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TDBookProvider</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)purchaseBookWithTitle:(<span class="built_in">NSString</span> *)bookTitle&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"You've bought \"%@\""</span>,bookTitle);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  TDClothesProvider.m</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"TDClothesProvider.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TDClothesProvider</span> () &lt;<span class="title">TDClothesProviderProtocol</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TDClothesProvider</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)purchaseClothesWithSize:(TDClothesSize )size&#123;</div><div class="line">    <span class="built_in">NSString</span> *sizeStr;</div><div class="line">    <span class="keyword">switch</span> (size) &#123;</div><div class="line">        <span class="keyword">case</span> TDClothesSizeLarge:</div><div class="line">            sizeStr = <span class="string">@"large size"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> TDClothesSizeMedium:</div><div class="line">            sizeStr = <span class="string">@"medium size"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> TDClothesSizeSmall:</div><div class="line">            sizeStr = <span class="string">@"small size"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"You've bought some clothes of %@"</span>,sizeStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>现在两个Provider的类写完，我们可以直接向供应商买东西了，但这跟我们的需求还有很大差异，我们需要一个中间的经销商<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  TDDealerProxy.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TDBookProvider.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TDClothesProvider.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TDDealerProxy</span> : <span class="title">NSProxy</span> &lt;<span class="title">TDBookProviderProtocol</span>, <span class="title">TDClothesProviderProtocol</span>&gt;</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span> )dealerProxy;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这里有两个要注意的问题：<br>1、TDDealerProxy这个子类必须要遵循之前定义的两个协议TDBookProviderProtocol与TDClothesProviderProtocol，目的是骗过编译器，让编译器认为这个类实现了上面两个协议<br>2、NSProxy类是没有init方法的，也就是说如果我们要获得一个NSProxy的实例，代码只需要这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSProxy</span> *proxyInstance = [<span class="built_in">NSProxy</span> alloc];</div></pre></td></tr></table></figure></p>
<p>接下来看实现文件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  TDDealerProxy.m</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"TDDealerProxy.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TDDealerProxy</span> () </span>&#123;</div><div class="line">    TDBookProvider          *_bookProvider;</div><div class="line">    TDClothesProvider       *_clothesProvider;</div><div class="line">    <span class="built_in">NSMutableDictionary</span>     *_methodsMap;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TDDealerProxy</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - class method</span></div><div class="line">+ (<span class="keyword">instancetype</span>)dealerProxy&#123;</div><div class="line">    <span class="keyword">return</span> [[TDDealerProxy alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - init</span></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    _methodsMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    _bookProvider = [[TDBookProvider alloc] init];</div><div class="line">    _clothesProvider = [[TDClothesProvider alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">//映射target及其对应方法名</span></div><div class="line">    [<span class="keyword">self</span> _registerMethodsWithTarget:_bookProvider];</div><div class="line">    [<span class="keyword">self</span> _registerMethodsWithTarget:_clothesProvider];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - private method</span></div><div class="line">- (<span class="keyword">void</span>)_registerMethodsWithTarget:(<span class="keyword">id</span> )target&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfMethods = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//获取target方法列表</span></div><div class="line">    Method *method_list = class_copyMethodList([target <span class="keyword">class</span>], &amp;numberOfMethods);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfMethods; i ++) &#123;</div><div class="line">        <span class="comment">//获取方法名并存入字典</span></div><div class="line">        Method temp_method = method_list[i];</div><div class="line">        SEL temp_sel = method_getName(temp_method);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *temp_method_name = sel_getName(temp_sel);</div><div class="line">        [_methodsMap setObject:target forKey:[<span class="built_in">NSString</span> stringWithUTF8String:temp_method_name]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(method_list);</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark - NSProxy override methods</span></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation&#123;</div><div class="line">    <span class="comment">//获取当前选择子</span></div><div class="line">    SEL sel = invocation.selector;</div><div class="line">    </div><div class="line">    <span class="comment">//获取选择子方法名</span></div><div class="line">    <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">    </div><div class="line">    <span class="comment">//在字典中查找对应的target</span></div><div class="line">    <span class="keyword">id</span> target = _methodsMap[methodName];</div><div class="line">    </div><div class="line">    <span class="comment">//检查target</span></div><div class="line">    <span class="keyword">if</span> (target &amp;&amp; [target respondsToSelector:sel]) &#123;</div><div class="line">        [invocation invokeWithTarget:target];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> forwardInvocation:invocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel&#123;</div><div class="line">    <span class="comment">//获取选择子方法名</span></div><div class="line">    <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">    </div><div class="line">    <span class="comment">//在字典中查找对应的target</span></div><div class="line">    <span class="keyword">id</span> target = _methodsMap[methodName];</div><div class="line"></div><div class="line">    <span class="comment">//检查target</span></div><div class="line">    <span class="keyword">if</span> (target &amp;&amp; [target respondsToSelector:sel]) &#123;</div><div class="line">        <span class="keyword">return</span> [target methodSignatureForSelector:sel];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>大功告成，现在我们的经销商也有了，最后要做的就是告诉经销商我们要买什么书跟什么衣服了（发消息）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    </div><div class="line">    TDDealerProxy *dealerProxy = [TDDealerProxy dealerProxy];</div><div class="line">    [dealerProxy purchaseBookWithTitle:<span class="string">@"Swift 100 Tips"</span>];</div><div class="line">    [dealerProxy purchaseClothesWithSize:TDClothesSizeMedium];</div><div class="line"></div><div class="line">    <span class="comment">// Override point for customization after application launch.</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行看看log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-08-06 01:10:27.095 TDProxyDemo[37732:924470] You&apos;ve bought &quot;Swift 100 Tips&quot;</div><div class="line">2016-08-06 01:10:27.095 TDProxyDemo[37732:924470] You&apos;ve bought some clothes of medium size</div></pre></td></tr></table></figure></p>
<p>Bravo！<a href="https://github.com/jojoting/TDProxyDemo">Demo地址戳我</a></p>
<p>总的来说，NSProxy这个在日常开发者很少见的类，的确有着它奇淫之处，这里推荐几个NSProxy相关的实践</p>
<p><a href="http://blog.sunnyxx.com/2014/08/24/objc-duck/">objc与鸭子对象 by sunny</a><br><a href="https://github.com/zwaldowski/BlocksKit">BlocksKit by zwaldowski</a><br>附上个人觉得写得很好的一篇源码解析：<br><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/BlocksKit/%E7%A5%9E%E5%A5%87%E7%9A%84%20BlocksKit%20%EF%BC%88%E4%B8%80%EF%BC%89.md">BlocksKit源码解析：《神奇的BlocksKit by Draveness》</a></p></div><a href="/2016/08/09/NSProxy——少见却神奇的类/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/20/阿里云服务器配置pptp-vpn/" class="post-title-link">阿里云服务器配置pptp-vpn</a></h2><div class="post-info">Jul 20, 2016</div><div class="post-content"><p>由于博客要搬家到阿里云，所以顺便买了个新加坡的服务器准备自己配一个vpn，放弃之前用的鱼摆摆。总体来说在阿里云上配置vpn还算比较简单，二十分钟就可以搭建完成了。<br>服务器操作系统：CentOS 6.5 32位<br>1、安装PPP以及PPTPPPP:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># yum install ppp</span></div></pre></td></tr></table></figure></p>
<p>PPTP:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># yum install pptp</span></div></pre></td></tr></table></figure></p>
<p>根据提示安装好就可以了<br>2、配置PPTP安装好PPTP后要先配置一下PPTP，进入配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># vim /etc/pptpd.conf</span></div></pre></td></tr></table></figure></p>
<p>在文件最底部可以看见两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#localip 192.168.0.1</div><div class="line">#remoteip 192.168.0.234-238,192.168.0.245</div></pre></td></tr></table></figure></p>
<p>把注释去掉：<br><code>localip 192.168.0.1</code><br><code>remoteip 192.168.0.234-238,192.168.0.245</code><br>然后保存退出即可<br>修改完配置文件后我们还要修改一下DNS<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># vim /etc/ppp/options.pptpd</span></div></pre></td></tr></table></figure></p>
<p>同样在文件最后两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#ms-dns 10.0.0.1</div><div class="line">#ms-dns 10.0.0.2</div></pre></td></tr></table></figure></p>
<p>去掉注释，并将DNS改为<br><code>ms-dns 8.8.8.8</code><br><code>ms-dns 8.8.4.4</code></p>
<p>然后保存退出<br><strong>注：此处8.8.8.8与8.8.4.4为谷歌的DNS，可以根据个人改为其他的也可以</strong></p>
<p>最后要设置一下账号密码，进入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># vim /etc/ppp/chap-secrets</span></div></pre></td></tr></table></figure></p>
<p>这个文件只有两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Secrets for authentication using CHAP</div><div class="line"># client server secret IP addresse</div></pre></td></tr></table></figure></p>
<p>按照文件提示的格式插入一行即可，例如插入：<br><code>guest pptp 123</code></p>
<p><strong>这样就代表可以使用guset这个账号，密码是123来连接VPN了</strong></p>
<p>3、修改内核转发配置现在PPTP以及配置完成了，只需要让内核支持转发就可以了修改配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># vim /etc/sysctl.conf</span></div></pre></td></tr></table></figure></p>
<p>将<br><code>net.ipv4.ip_forward = 0</code>改为<code>net.ipv4.ip_forward = 1</code></p>
<p><code>net.ipv4.tcp_syncookies = 1</code>注释掉，改为<code>#net.ipv4.tcp_syncookies = 1</code>保存退出同时执行命令使其生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># sysctl -p</span></div></pre></td></tr></table></figure></p>
<p>最后，还需要添加iptables的转发规则：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth1 -jMASQUERADE</span></div></pre></td></tr></table></figure></p>
<p><strong>注：这里由于阿里云双网卡，eth0是内网，eth1才是外网。然后保存一下配置并重启iptables</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># service iptables save</span></div><div class="line">[root@jojoServer ~]<span class="comment"># service iptables restart</span></div></pre></td></tr></table></figure></p>
<p>4、重启pptp<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@jojoServer ~]<span class="comment"># service pptpd restart</span></div></pre></td></tr></table></figure></p>
<p>5、连接vpn选择配置已经全部完成了，可以在PC或移动端通过之前添加的账号密码连接并使用VPN了<br>6、配置内网ip不走vpn由于连接VPN后默认所有的请求都会走VPN，所以打开国内网站就会比较慢如果忍受不了的，可以在电脑上配置一下这里给个<a href="https://github.com/jimmyxu/chnroutes">github地址</a>里面有详细的教程了，linux，mac os，windows都支持<br>祝大家翻墙愉快</p></div><a href="/2016/07/20/阿里云服务器配置pptp-vpn/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/10/15/安全的NSArray与NSMutableArray操作/" class="post-title-link">安全的NSArray与NSMutableArray操作</a></h2><div class="post-info">Oct 15, 2015</div><div class="post-content"><p>我们使用NSArray或者NSMutableArray时，通常调用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (ObjectType)objectAtIndex:(<span class="built_in">NSUInteger</span>)index;</div></pre></td></tr></table></figure></p>
<p>来通过索引获取对象。但是在使用这个方法时经常会抛出越界的异常，例如定义一个数组，并获取指定下标的值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUInteger</span> index = <span class="number">4</span>;</div><div class="line"><span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc]initWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="keyword">id</span> obj = [arr objectAtIndex:index];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"object at index:%@"</span>,obj);</div></pre></td></tr></table></figure></p>
<p>这时会导致程序出错，错误日志：</p>
<blockquote>
<p><strong>*</strong> Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘<strong>* -[__NSArrayI objectAtIndex:]: index 4 beyond bounds [0 .. 2]’</strong></p>
</blockquote>
<p>就是我们经常遇到的数组越界问题，为了避免这种问题的发生，我们应该对要穿入的索引值进行判断，如果超出了数组的边界，就应该直接返回空值。代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">        <span class="built_in">NSUInteger</span> index = <span class="number">4</span>;</div><div class="line">        <span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc]initWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>, <span class="literal">nil</span>];</div><div class="line">        <span class="keyword">id</span> obj = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> (index &gt; arr.count) &#123;</div><div class="line">            obj = <span class="literal">nil</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            obj = [arr objectAtIndex:index];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"object at index:%@"</span>,obj);</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<blockquote>
<p><strong>object at index:(null)</strong></p>
</blockquote>
<p>因此，我们如果需要避免数组越界发生，有必要对索引值进行一次判断，但如果在工程中每一处都加判断未免过于麻烦，因此我们可以写一个NSArray的category扩展类，并重写<figure class="highlight plain"><figcaption><span>)index```方法。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">```objc</div><div class="line">- (id)safe_objectAtIndex:(NSUInteger )index&#123;</div><div class="line">    if (index &gt; self.count || index &lt; 0) &#123;</div><div class="line">        //index超出数组界限</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [self objectAtIndex:index];</div></pre></td></tr></table></figure></p>
<p>但同时我们应注意一个问题，如果通过这种方式强制性避免了越界导致的异常，可能会使工程中的其它部分受到一定程度的影响。因此应选择性地使用此方法。</p>
<p><a href="https://github.com/jojoting/TDSafeArray">github地址</a></p></div><a href="/2015/10/15/安全的NSArray与NSMutableArray操作/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/10/13/nil指针对NSDictionary及NSArray初始化的影响/" class="post-title-link">nil指针对NSDictionary及NSArray初始化的影响</a></h2><div class="post-info">Oct 13, 2015</div><div class="post-content"><p>最近在做项目的时候遇到一个挺坑的崩溃问题，是由于NSDictionary初始化时nil指针引起的崩溃。假设我们现在要初始化一个{key1 : value1, key2 : value2, key3 : value3}的NSDictionary，一般有两种初始化方法：</p>
<p>1、使用标准的初始化方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dictionary ＝[[<span class="built_in">NSDictionaryalloc</span>] initWithObjectsAndKeys:value1,<span class="string">@"key1"</span>,value2,<span class="string">@"key2"</span>, value3 ,<span class="string">@"value3"</span>,<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>2、使用ios6.0以后新支持的初始化方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dictionary =@&#123;<span class="string">@"key1"</span> : value1,<span class="string">@"key2"</span> : value2,<span class="string">@"key3"</span> : value3&#125;;</div></pre></td></tr></table></figure></p>
<p>现在我们对value1 value2 value3进行赋值，并把value2设为nil指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *value1 =<span class="string">@"value1"</span>;<span class="built_in">NSString</span> *value2 =<span class="literal">nil</span>;<span class="built_in">NSString</span> *value3 =<span class="string">@"value3"</span>;</div></pre></td></tr></table></figure></p>
<p>这时如果使用第二种初始化方法，运行程序会发现崩溃，日志如下：</p>
<blockquote>
<p>DictionaryTextDemo[29390:1329578]<strong><em> Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘</em></strong> -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[1]’</p>
</blockquote>
<p>发现系统会阻止你向object[1]插入一个nil指针，查询苹果官方文档得到</p>
<blockquote>
<p>Discussion<br>This method steps through the objects andkeys arrays, creating entries in the new dictionary as it goes. AnNSInvalidArgumentException is raised if a key or value object isnil.</p>
</blockquote>
<p>也就是说使用这种初始化方法的时候必须保证key跟value都不为nil，因此我们需要在初始化之前对其进行判断，如果为nil就不加入字典。但是如果有需求让value必须为空的时候，可以将value赋值为<code>[NSNull null]</code>这样就可以成功插入字典，最后打印出来的结果是</p>
<blockquote>
<p>DictionaryTextDemo[29510:1338517] dictionary : {key1 = value1;key2 = “”;value3 = value3;}</p>
</blockquote>
<p>另一种解决方法就是使用标准的初始化方法，即第一种初始化方法。但同时也要注意一个问题，使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NDictionary *dictionary = [[<span class="built_in">NSDictionaryalloc</span>]initWithObjectsAndKeys:value1,<span class="string">@"key1"</span>,value2,<span class="string">@"key2"</span>, value3 ,<span class="string">@"value3"</span>,<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>如果我们把其中一个key或者value设为nil指针，那么系统会判断为全部对象插入完成，即相当于我们初始化数组及字典时最后的nil。因此这种方法虽然能避免插入nil指针时抛出的异常，但可能会成为一个工程中很大的安全隐患，并且难以发现。所以推荐使用第二种初始化方法，并对nil指针进行必要的判断，选择性使用<code>[NSNull null]</code>来实现特点的需求。同理，使用NSArray时也应该注意这类问题。</p></div><a href="/2015/10/13/nil指针对NSDictionary及NSArray初始化的影响/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"></div><div class="copyright"><p>© 2016 <a href="https://dingtz.com">Jojo Ding</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>