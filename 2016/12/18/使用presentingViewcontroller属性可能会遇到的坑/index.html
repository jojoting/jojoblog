<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 使用presentingViewController属性可能会遇到的坑 · JOJOTOV</title><meta name="description" content="presentingViewController, presentViewController, presentedViewController"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/official_account_avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://dingtz.com/atom.xml" title="JOJOTOV"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/blogLogo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jojoting" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://cn.linkedin.com/in/同舟-丁-77689b10b" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">使用presentingViewController属性可能会遇到的坑</h1><div class="post-info">Dec 18, 2016</div><div class="post-content"><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假设现在有这样一个场景，我有一个根导航控制器<code>RootNavigationController</code>，它的根视图控制器<code>ViewController</code>有一个子控制器<code>UINavigationController</code>，这个导航控制器的根控制器是<code>FirstViewController</code>。</p>
<p>在<code>FirstViewController</code>中，添加一个方法使用<code>presentModelViewController</code>的方式跳转到另一个根控制器为<code>NextViewController</code>的<code>UINavigationController</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/797083-a034d3bd0033a0a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制器层级"></p>
<p>如果<code>NextViewController</code>中获取它的<code>presentingViewController</code>属性，结果得到的是<code>RootNavigationController</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-12-18 10:34:09.548 PresentVCDemo[27202:22455163] viewDidLoad &lt;RootNavigationController: 0x7ff29f83ba00&gt;</div><div class="line">2016-12-18 10:34:09.549 PresentVCDemo[27202:22455163] viewDidLoad &lt;ViewController: 0x7ff29de05870&gt;</div><div class="line">2016-12-18 10:34:09.572 PresentVCDemo[27202:22455163] viewDidLoad &lt;UINavigationController: 0x7ff29f022a00&gt;</div><div class="line">2016-12-18 10:34:09.573 PresentVCDemo[27202:22455163] viewDidLoad &lt;FirstViewController: 0x7ff29dc0c680&gt;</div><div class="line">2016-12-18 10:34:52.785 PresentVCDemo[27202:22455163] Presenting Controller : &lt;RootNavigationController: 0x7ff29f83ba00&gt;</div></pre></td></tr></table></figure>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>苹果官方的<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW7" target="_blank" rel="external">ViewController Programming Guide</a>中关于<strong>Presenting a View Controller</strong>的部分是这样说的</p>
<blockquote>
<p>The view controller that calls the presentViewController:animated:completion: method may not be the one that actually performs the modal presentation. The presentation style determines how that view controller is to be presented, including the characteristics required of the presenting view controller. </p>
</blockquote>
<p>也就是说，在调用<code>presentViewController:animated:completion:</code>方法时，真正作为跳转的容器并不一定是调用这个方法的view controller，而是取决于<code>modalPresentationStyle</code>。例如，一个全屏的跳转必须由一个全屏的view controller来完成。如果当前的控制器不能满足，那么系统会自动沿着视图控制器的层级向上查找。</p>
<p>在我们的层级中，只有两个<code>UINavigationController</code>是全屏的，因此，这两个控制器都有可能成为最终跳转的容器。可是为什么最终是<code>RootNavigationController</code>完成了这次跳转而不是<code>FirstViewController</code>的导航控制器呢？</p>
<p>在<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/TheViewControllerHierarchy.html#//apple_ref/doc/uid/TP40007457-CH33-SW1" target="_blank" rel="external">The View Controller Hierachy</a>关于Presented View Controller中找到了这样一句话：</p>
<blockquote>
<p>When you present a view controller, UIKit looks for a view controller that provides a suitable context for the presentation. In many cases, UIKit chooses the nearest container view controller but it might also choose the window’s root view controller.</p>
</blockquote>
<p>因此，在一开始提到的场景中，UIKit帮我们选择了UIWindow的根视图控制器，而不是<code>FirstViewController</code>的导航控制器。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在某些特定的业务需求中，我们需要利用<code>presentingViewController</code>拿到<code>FirstViewController</code>的导航控制器。</p>
<p>解决这个需求，我们需要用到一对属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> definesPresentationContext;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalPresentationStyle</span> modalPresentationStyle;</div></pre></td></tr></table></figure></p>
<p><code>modalPresentationStyle</code>属性决定了将要present的控制器以何种方式展现，默认值为<code>UIModalTransitionStyleCoverVertical</code></p>
<p><code>definesPresentationContext</code>就有点神奇了，他的注释文档是这么写的</p>
<blockquote>
<p>Determines which parent view controller’s view should be presented over for presentations of type UIModalPresentationCurrentContext.  If no ancestor view controller has this flag set, then the presenter will be the root view controller.</p>
</blockquote>
<p>简单来说，如果把一个控制器的<code>definesPresentationContext</code>属性设置为YES，那么在需要进行<code>UIModalPresentationCurrentContext</code>类型的跳转的时候，UIKit会使用视图层级内的这个控制器来进行跳转。</p>
<p>在<code>FirstViewController</code>中加入下面的代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.navigationController setDefinesPresentationContext:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></p>
<p>并在跳转的时候设置目标控制器的<code>modalPresentationStyle</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[nav setModalPresentationStyle:<span class="built_in">UIModalPresentationCurrentContext</span>];</div><div class="line">[<span class="keyword">self</span> presentViewController:nav animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>接下来看一下Log日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-12-18 11:59:20.041 PresentVCDemo[32336:22885768] viewDidLoad &lt;RootNavigationController: 0x7fd6f4810600&gt;</div><div class="line">2016-12-18 11:59:20.042 PresentVCDemo[32336:22885768] viewDidLoad &lt;ViewController: 0x7fd6f2c04110&gt;</div><div class="line">2016-12-18 11:59:20.052 PresentVCDemo[32336:22885768] viewDidLoad &lt;UINavigationController: 0x7fd6f381ce00&gt;</div><div class="line">2016-12-18 11:59:20.052 PresentVCDemo[32336:22885768] viewDidLoad &lt;FirstViewController: 0x7fd6f2f090c0&gt;</div><div class="line">2016-12-18 11:59:20.920 PresentVCDemo[32336:22885768] Presenting Controller : &lt;UINavigationController: 0x7fd6f381ce00&gt;</div></pre></td></tr></table></figure></p>
<p>大功告成！现在<code>presentingViewController</code>能够获取到我们期望的对象了。</p>
<a id="more"></a>
</div></article></div></section><footer><div class="paginator"><a href="/2016/12/18/Link（直达链接）开发/" class="prev">PREV</a><a href="/2016/08/09/NSProxy——少见却神奇的类/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 <a href="https://dingtz.com">Jojo Ding</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>